material {
    name : DepthOfField,
    parameters : [
        {
           type : sampler2d,
           name : foreground,
           precision: medium
        },
        {
           type : sampler2d,
           name : background,
           precision: medium
        },
        {
           type : sampler2d,
           name : cocFgBg,
           precision: medium
        },
        {
           type : sampler2d,
           name : tiles,
           precision: medium
        }
    ],
    variables : [
        vertex
    ],
    domain : postprocess,
    depthWrite : false,
    depthCulling : false
}

vertex {
    void postProcessVertex(inout PostProcessVertexInputs postProcess) {
        postProcess.vertex.xy = postProcess.normalizedUV;
    }
}

fragment {

#include "dofUtils.fs"


#define RING_DENSITY 6.0
#define RING_COUNT	 4.0
#define SAMPLE_COUNT ((RING_DENSITY * RING_COUNT * (RING_COUNT - 1.0) + 2.0) * 0.5)

void dummy(){}

layout(location = 1) out float outAlpha;


float sampleWeight(float coc) {
    // The contribution of sample is inversely proportional to *it's* area
    // (the larger area, the fainter it is).
    // In theory this factor should be 1 / pi * radius^2, however 1/pi is a constant, and
    // because we divide by the total weight eventually, it can be ommited, in fact, any
    // constant can be used. Here we use MAX_COC_RADIUS * MAX_COC_RADIUS instead of 1/pi,
    // because this allows us to fit in mediump precision.
    return (MAX_COC_RADIUS * MAX_COC_RADIUS) / (max(coc * coc, 0.5));
}

float intersection(float border, float absCoc, float mip) {
    return saturate((absCoc - border) * pow(0.5, mip) + 0.5);
}

float rcp(float x) {
    return 1.0 / x;
}

/*
 * We use the accumulation method described in
 * "Bokeh depth of field in a single pass" by Dennis Gustafsson
 * [http://blog.tuxedolabs.com/2018/05/04/bokeh-depth-of-field-in-single-pass.html]
 *
 * We initialize the accumulator with the center value and our initial total weight starts at 1.0.
 * Then, each time a new sample does not intersect with the center (meaning it doesn't contribute
 * to this fragment), we scale the current accumulation to a weight of 'i + 1'.
 * Samples that do contribute are simply acumulated, also increasing the total weight by 1.
 * At the end of the process we're guaranteed to have a total weight of SAMPLE_COUNT + 1.
 * The scale factor at each "miss" step is simply (i + 1) / i.
 * With this technique the weight of each sample is constant; in reality it should depend on
 * the circle-of-confusion area.
 */

void accumulateBackground(inout vec4 background, inout float opacity,
        inout float i, highp vec2 pos, float radius, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).g;
    vec4 s = textureLod(materialParams_background, pos, mip);
    float o = cocToAlpha(coc);
    float w = intersection(radius, abs(coc), mip) * isBackground(coc);
    background += mix(background * rcp(i), s, w);
    opacity += mix(opacity * rcp(i), o, w);
    i += 1.0;
    //w *= sampleWeight(coc);
    //background += s * w;
    //opacity += o * w;
    //i += w;
}

void accumulateForeground(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 pos, float radius, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).r;
    vec4 s = textureLod(materialParams_foreground, pos, mip);
    float o = cocToAlpha(coc);
    float w = intersection(radius, abs(coc), mip) * isForeground(coc);
    foreground += mix(foreground * rcp(i), s, w);
    opacity += mix(opacity * rcp(i), o, w);
    i += 1.0;
    //w *= sampleWeight(coc);
    //foreground += s * w;
    //opacity += o * w;
    //i += w;
}

void accumulateBackgroundFirst(inout vec4 background, inout float opacity, inout float i,
        highp vec2 pos, float radius, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).g;
    background = textureLod(materialParams_background, pos, mip);
    opacity = cocToAlpha(coc);
    i += 1.0;
}

void accumulateForegroundFirst(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 pos, float radius, float mip) {
    float coc = textureLod(materialParams_cocFgBg, pos, mip).r;
    foreground = textureLod(materialParams_foreground, pos, mip);
    opacity = cocToAlpha(coc);
    i += 1.0;
}

void accumulateBackgroundMirror(inout vec4 background, inout float opacity, inout float i,
        highp vec2 center, vec2 offset, float radius, float mip) {
    accumulateBackground(background, opacity, i, center + offset, radius, mip);
    accumulateBackground(background, opacity, i, center - offset, radius, mip);
}

void accumulateForegroundMirror(inout vec4 foreground, inout float opacity, inout float i,
        highp vec2 center, vec2 offset, float radius, float mip) {
    // The code below is equivalent to:
    //      accumulateForeground(foreground, opacity, i, center + offset, radius, mip);
    //      accumulateForeground(foreground, opacity, i, center - offset, radius, mip);
    // but selects the min coc of opposite samples as a way to guess the color occluded by
    // the geometry.
    
    float coc0 = textureLod(materialParams_cocFgBg, center + offset, mip).r;
    float coc1 = textureLod(materialParams_cocFgBg, center - offset, mip).r;
    float coc = min(coc0, coc1);
    vec4 s0 = textureLod(materialParams_foreground, center + offset, mip);
    vec4 s1 = textureLod(materialParams_foreground, center - offset, mip);
    float o = cocToAlpha(coc);
    float w = intersection(radius, abs(coc), mip) * isForeground(coc);
    foreground += mix(foreground * rcp(i), s0, w);
    opacity += mix(opacity * rcp(i), o, w);
    i += 1.0;
    foreground += mix(foreground * rcp(i), s1, w);
    opacity += mix(opacity * rcp(i), o, w);
    i += 1.0;
}

float getMipLevel(float kernelSize) {
    float mip = log2(kernelSize * rcp(RING_COUNT + 0.5));
    //mip = floor(0.5 + mip);
    return mip;
}

void postProcess(inout PostProcessInputs postProcess) {
    highp vec2 uv = variable_vertex.xy;
    vec2 tiles = textureLod(materialParams_tiles, uv, 0.0).rg;

    /*
     * Tiles that are neither foreground or background (in focus) can be skipped
     */

    if (isTrivialTile(tiles)) {
        postProcess.color = vec4(0.0);
        outAlpha = 0.0;
        return;
    }

    vec4 foreground = vec4(0.0);
    vec4 background = vec4(0.0);
    float fgOpacity = 0.0;
    float bgOpacity = 0.0;

    // we use the full resolution pixel size because that's the unit the CoC is in
    highp vec2 fullResPixelSize = 0.5 / vec2(textureSize(materialParams_foreground, 0));

    // When using mipmaping the noise seems to hurt more than it helps
    //float randomAngle = random(gl_FragCoord.xy) * (2.0 * PI);
    //float random01 = random(gl_FragCoord.xy * vec2(7.0, 11.0));
    //vec2  randomUniformDisk = 0.5 * sqrt(random01) * vec2(cos(randomAngle), sin(randomAngle));
    //vec2  noise = randomUniformDisk * rcp(RING_COUNT + 0.5);
    vec2 noise = vec2(0.0);

    if (isFastTile(tiles)) {
        // for a foreground tile, the kernel size is the largest CoC radius
        float coc = abs(tiles.r);
        float kernelSize = coc;
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;

        for (float i = 0.0; i < RING_COUNT; i += 1.0) {
            float radius = (kernelSize / RING_COUNT) * i;
            float count = max(1.0, RING_DENSITY * i);
            float inc = 2.0 * PI / count;
            vec2 t = vec2(cos(inc), sin(inc));
            vec4 r = vec4(t.x, -t.y, t.y, t.x);
            float firstSamplePosition = mod(i, 2.0) * 0.5 * inc;
            vec2 p = radius * vec2(cos(firstSamplePosition), sin(firstSamplePosition));
            for (float j = 0.0; j < count; j += 1.0) {
                vec2 pos = uvCenter + p * fullResPixelSize;
                vec4 s = textureLod(materialParams_foreground, pos, mip);
                float o = cocToAlpha(coc);
                foreground += s;
                fgOpacity += o;
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        foreground *= rcp(SAMPLE_COUNT);
        fgOpacity  *= rcp(SAMPLE_COUNT);
        foreground *= fgOpacity;
        //foreground.b += 0.4;
#if POST_PROCESS_OPAQUE
        // kill the work performed above
        foreground.a = 0.0;
#endif
        postProcess.color  = foreground;
        outAlpha           = fgOpacity;
        return;
    }

    /*
     * Then process the slow foreground / background tiles
     */

    if (isForegroundTile(tiles)) {
        // for a foreground tile, the kernel size is the largest CoC radius
        float kernelSize = -tiles.g;
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;
        float c = 0.0;

        // the center sample is handled separatly, since it's by itself
        accumulateForegroundFirst(foreground, fgOpacity, c, uvCenter, 0.0, mip);

        for (float i = 1.0; i < RING_COUNT; i += 1.0) {
            float radius = (kernelSize / RING_COUNT) * i;
            float count = max(1.0, RING_DENSITY * i);
            float inc = 2.0 * PI / count;
            vec2 t = vec2(cos(inc), sin(inc));
            vec4 r = vec4(t.x, -t.y, t.y, t.x);
            float firstSamplePosition = mod(i, 2.0) * 0.5 * inc;
            vec2 p = radius * vec2(cos(firstSamplePosition), sin(firstSamplePosition));
            for (float j = 0.0; j < count; j += 2.0) {
                accumulateForegroundMirror(foreground, fgOpacity, c,
                        uvCenter, p * fullResPixelSize, radius, mip);
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        foreground *= rcp(c);
        fgOpacity  *= rcp(c);
        foreground *= fgOpacity;
        //foreground.r += 0.1;
    }

    if (isBackgroundTile(tiles)) {
        vec2 centerCoc  = textureLod(materialParams_cocFgBg, uv, 0.0).rg;
        float kernelSize = abs(centerCoc.g);
        float mip = getMipLevel(kernelSize);
        vec2 uvCenter = uv + noise * kernelSize * fullResPixelSize;
        float c = 0.0;

        // the center sample is handled separatly, since it's by itself
        accumulateBackgroundFirst(background, bgOpacity, c, uvCenter, 0.0, mip);

        for (float i = 1.0; i < RING_COUNT; i += 1.0) {
            float radius = (kernelSize / RING_COUNT) * i;
            float count = max(1.0, RING_DENSITY * i);
            float inc = 2.0 * PI / count;
            vec2 t = vec2(cos(inc), sin(inc));
            vec4 r = vec4(t.x, -t.y, t.y, t.x);
            float firstSamplePosition = mod(i, 2.0) * 0.5 * inc;
            vec2 p = radius * vec2(cos(firstSamplePosition), sin(firstSamplePosition));
            for (float j = 0.0; j < count; j += 2.0) {
                accumulateBackgroundMirror(background, bgOpacity, c,
                        uvCenter, p * fullResPixelSize, radius, mip);
                p = vec2(dot(p, r.xy), dot(p, r.zw));
            }
        }
        background *= rcp(c);
        bgOpacity  *= rcp(c);
        background *= bgOpacity;
        //background.g += 0.1;
    }

#if POST_PROCESS_OPAQUE
    // kill the work performed above
    foreground.a = 0.0;
    background.a = 0.0;
#endif

    // composite the foreground and background layers together.
    // the downside of doing this is that we couldn't use a different upscaler for each
    // layer, but this is a lot less costly
    postProcess.color = foreground + (1.0 - fgOpacity) * background;
    outAlpha          = fgOpacity  + (1.0 - fgOpacity) * bgOpacity;
}

}
